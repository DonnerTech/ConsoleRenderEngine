#pragma once
/*
Generated by ChatGPT for rapid prototyping cross-platform support

getasynckeystate.h
A drop-in cross-platform approximation of Win32 GetAsyncKeyState.

Usage:
  // In one .c/.cpp only:
  #define GETASYNCKEYSTATE_IMPLEMENTATION
  #include "getasynckeystate.h"

  // In other units:
  #include "getasynckeystate.h"

Behavior:
  - On Windows (_WIN32) this forwards to the real GetAsyncKeyState().
  - On other platforms this provides an approximation:
      * high-order bit (0x8000) set when key is currently down
      * low-order bit (0x0001) set if key was pressed since last call
        to GetAsyncKeyState for that virtual-key (per-process state tracked).
  - The header provides common VK_* macros when missing.
  - Not all VK codes are mapped on non-Windows systems. Mappings for ASCII letters/digits,
    arrows, space, enter, escape, ctrl/shift/alt are included. You can extend mapping table.

Limitations:
  - This is an approximation: physical scancodes/OS virtual codes differ between platforms.
  - macOS and X11 mappings are best-effort for many common keys; less-common VK_* may not work.
  - Thread-safety: simple mutex is used where available; but avoid heavy concurrency.
  - On non-Windows, low-order "pressed since last call" semantics are implemented per-key,
    tracked inside the library (not by the OS), so behavior will differ from Windows edge cases.
*/

#ifndef GETASYNCKEYSTATE_H
#define GETASYNCKEYSTATE_H

#ifdef __cplusplus
extern "C" {
#endif

    /* Provide a SHORT type if missing */
#include <stdint.h>
    typedef short SHORT;

    /* If compiling on Windows, just use the real function */
#ifdef _WIN32
#include <windows.h>
/* Nothing else needed - user can call GetAsyncKeyState normally */
#else

/* Provide common VK_ macros if user didn't include windows.h */
#ifndef VK_LBUTTON
/* Commonly used virtual-key codes (subset) */
#define VK_LBUTTON       0x01
#define VK_RBUTTON       0x02
#define VK_CANCEL        0x03
#define VK_MBUTTON       0x04
#define VK_BACK          0x08
#define VK_TAB           0x09
#define VK_CLEAR         0x0C
#define VK_RETURN        0x0D
#define VK_SHIFT         0x10
#define VK_CONTROL       0x11
#define VK_MENU          0x12 /* Alt */
#define VK_PAUSE         0x13
#define VK_CAPITAL       0x14
#define VK_ESCAPE        0x1B
#define VK_SPACE         0x20
#define VK_PRIOR         0x21
#define VK_NEXT          0x22
#define VK_END           0x23
#define VK_HOME          0x24
#define VK_LEFT          0x25
#define VK_UP            0x26
#define VK_RIGHT         0x27
#define VK_DOWN          0x28
#define VK_PRINT         0x2A
#define VK_SNAPSHOT      0x2C
#define VK_INSERT        0x2D
#define VK_DELETE        0x2E
#define VK_0             0x30
#define VK_1             0x31
#define VK_2             0x32
#define VK_3             0x33
#define VK_4             0x34
#define VK_5             0x35
#define VK_6             0x36
#define VK_7             0x37
#define VK_8             0x38
#define VK_9             0x39
#define VK_A             0x41
#define VK_B             0x42
#define VK_C             0x43
#define VK_D             0x44
#define VK_E             0x45
#define VK_F             0x46
#define VK_G             0x47
#define VK_H             0x48
#define VK_I             0x49
#define VK_J             0x4A
#define VK_K             0x4B
#define VK_L             0x4C
#define VK_M             0x4D
#define VK_N             0x4E
#define VK_O             0x4F
#define VK_P             0x50
#define VK_Q             0x51
#define VK_R             0x52
#define VK_S             0x53
#define VK_T             0x54
#define VK_U             0x55
#define VK_V             0x56
#define VK_W             0x57
#define VK_X             0x58
#define VK_Y             0x59
#define VK_Z             0x5A
#endif /* VK_LBUTTON */

#include <string.h>
#include <stdlib.h>

/* Public functions */
    SHORT GetAsyncKeyState(int vKey);

    /* OPTIONAL: call these if you want explicit init/shutdown (library lazily initializes) */
    int GAS_Init(void);     /* returns 1 on success, 0 on failure */
    void GAS_Shutdown(void);

#endif /* !_WIN32 */

#ifdef __cplusplus
}
#endif

/* Implementation block - define GETASYNCKEYSTATE_IMPLEMENTATION in exactly one translation unit */
#ifdef GETASYNCKEYSTATE_IMPLEMENTATION

/* ---------------------- Platform-specific implementations ---------------------- */

#ifdef _WIN32
/* On Windows just forward */
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
//SHORT GetAsyncKeyState(int vKey) {
//    return (SHORT)GetAsyncKeyState((int)vKey);
//}
int GAS_Init(void) { return 1; }
void GAS_Shutdown(void) { (void)0; }

#else /* Non-Windows: implement with X11 (Linux) and Quartz (macOS) */

#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

/* minimal threading mutex support */
#if defined(_MSC_VER)
#include <windows.h>
typedef CRITICAL_SECTION gas_mutex_t;
static void gas_mutex_init(gas_mutex_t* m) { InitializeCriticalSection(m); }
static void gas_mutex_lock(gas_mutex_t* m) { EnterCriticalSection(m); }
static void gas_mutex_unlock(gas_mutex_t* m) { LeaveCriticalSection(m); }
static void gas_mutex_destroy(gas_mutex_t* m) { DeleteCriticalSection(m); }
#elif defined(__STDC_NO_THREADS__) || !defined(__STDC_NO_THREADS__)
  /* try pthreads */
#include <pthread.h>
typedef pthread_mutex_t gas_mutex_t;
static void gas_mutex_init(gas_mutex_t* m) { pthread_mutex_init(m, NULL); }
static void gas_mutex_lock(gas_mutex_t* m) { pthread_mutex_lock(m); }
static void gas_mutex_unlock(gas_mutex_t* m) { pthread_mutex_unlock(m); }
static void gas_mutex_destroy(gas_mutex_t* m) { pthread_mutex_destroy(m); }
#else
typedef int gas_mutex_t;
static void gas_mutex_init(gas_mutex_t* m) { (void)m; }
static void gas_mutex_lock(gas_mutex_t* m) { (void)m; }
static void gas_mutex_unlock(gas_mutex_t* m) { (void)m; }
static void gas_mutex_destroy(gas_mutex_t* m) { (void)m; }
#endif

/* Keep track of previous key states for low-bit (pressed since last call) semantics */
static unsigned char gas_prev_down[256];
static int gas_initialized = 0;
static gas_mutex_t gas_lock;

/* Platform backends */
#if defined(__linux__) || defined(__unix__) || defined(__CYGWIN__)

  /* X11 backend */
#include <X11/Xlib.h>
#include <X11/keysym.h>

static Display* gas_display = NULL;
static int gas_x11_init(void) {
    if (gas_display) return 1;
    gas_display = XOpenDisplay(NULL);
    return gas_display != NULL;
}
static void gas_x11_shutdown(void) {
    if (gas_display) { XCloseDisplay(gas_display); gas_display = NULL; }
}

/* Map some Windows VK codes to X11 keysyms (best-effort). Extend as needed. */
static KeySym gas_vk_to_keysym(int vk) {
    if (vk >= 'A' && vk <= 'Z') return XK_A + (vk - 'A');
    if (vk >= '0' && vk <= '9') return XK_0 + (vk - '0');
    switch (vk) {
    case VK_LEFT: return XK_Left;
    case VK_RIGHT: return XK_Right;
    case VK_UP: return XK_Up;
    case VK_DOWN: return XK_Down;
    case VK_SPACE: return XK_space;
    case VK_RETURN: return XK_Return;
    case VK_ESCAPE: return XK_Escape;
    case VK_SHIFT: return XK_Shift_L;
    case VK_CONTROL: return XK_Control_L;
    case VK_MENU: return XK_Alt_L;
    default: return NoSymbol;
    }
}

static int gas_x11_is_down(int vKey) {
    if (!gas_x11_init()) return 0;
    unsigned char keys[32];
    XQueryKeymap(gas_display, keys);
    KeySym ks = gas_vk_to_keysym(vKey);
    if (ks == NoSymbol) return 0;
    KeyCode kc = XKeysymToKeycode(gas_display, ks);
    if (kc == 0) return 0;
    int byte = kc >> 3;
    int bit = kc & 7;
    return (keys[byte] & (1 << bit)) != 0;
}

#elif defined(__APPLE__) && TARGET_OS_MAC
  /* macOS backend using Quartz */
#include <ApplicationServices/ApplicationServices.h>

static int gas_macos_init(void) {
    /* nothing to init for CGEventSourceKeyState */
    return 1;
}
static void gas_macos_shutdown(void) {}

/* Minimal mapping from VK to macOS virtual keycodes (hardware dependent).
   This mapping covers common keys on US keyboards; it's not exhaustive.
   You can extend it per your keyboard layout. */
static uint16_t gas_vk_to_macos_keycode(int vk) {
    if (vk >= 'A' && vk <= 'Z') {
        /* macOS keycodes are not direct; provide a best-effort mapping for letters */
        /* This mapping is common for US QWERTY but may vary on some machines. */
        static const uint16_t mapAtoZ[26] = {
          0x00 /*A*/, 0x0B /*B*/, 0x08 /*C*/, 0x02 /*D*/, 0x0E /*E*/, 0x03 /*F*/,
          0x05 /*G*/, 0x04 /*H*/, 0x22 /*I*/, 0x26 /*J*/, 0x28 /*K*/, 0x25 /*L*/,
          0x2E /*M*/, 0x2D /*N*/, 0x1F /*O*/, 0x23 /*P*/, 0x0C /*Q*/, 0x0F /*R*/,
          0x01 /*S*/, 0x11 /*T*/, 0x20 /*U*/, 0x09 /*V*/, 0x0D /*W*/, 0x07 /*X*/,
          0x10 /*Y*/, 0x06 /*Z*/
        };
        return mapAtoZ[vk - 'A'];
    }
    if (vk >= '0' && vk <= '9') {
        static const uint16_t map0to9[10] = {
          0x1D /*0*/, 0x12 /*1*/, 0x13 /*2*/, 0x14 /*3*/, 0x15 /*4*/,
          0x17 /*5*/, 0x16 /*6*/, 0x1A /*7*/, 0x1C /*8*/, 0x19 /*9*/
        };
        return map0to9[vk - '0'];
    }
    switch (vk) {
    case VK_LEFT: return 0x7B;
    case VK_RIGHT: return 0x7C;
    case VK_UP: return 0x7E;
    case VK_DOWN: return 0x7D;
    case VK_SPACE: return 0x31;
    case VK_RETURN: return 0x24;
    case VK_ESCAPE: return 0x35;
    case VK_SHIFT: return 0x38;
    case VK_CONTROL: return 0x3B;
    case VK_MENU: return 0x3A; /* Option/Alt */
    default: return UINT16_MAX;
    }
}

static int gas_macos_is_down(int vKey) {
    uint16_t kc = gas_vk_to_macos_keycode(vKey);
    if (kc == UINT16_MAX) return 0;
    /* CGEventSourceKeyState returns true if key is down */
    return CGEventSourceKeyState(kCGEventSourceStateCombinedSessionState, kc);
}

#else
  /* Fallback: no platform backend available */
static int gas_noop_init(void) { return 0; }
static void gas_noop_shutdown(void) {}
static int gas_noop_is_down(int vKey) { (void)vKey; return 0; }
#endif

/* Generic init/shutdown/is_down wrappers */
int GAS_Init(void) {
    if (gas_initialized) return 1;
    gas_mutex_init(&gas_lock);
#if defined(__linux__) || defined(__unix__) || defined(__CYGWIN__)
    if (!gas_x11_init()) {
        gas_mutex_destroy(&gas_lock);
        return 0;
    }
#elif defined(__APPLE__) && TARGET_OS_MAC
    if (!gas_macos_init()) {
        gas_mutex_destroy(&gas_lock);
        return 0;
    }
#else
    /* no backend */
    gas_mutex_destroy(&gas_lock);
    return 0;
#endif
    memset(gas_prev_down, 0, sizeof(gas_prev_down));
    gas_initialized = 1;
    return 1;
}

void GAS_Shutdown(void) {
    if (!gas_initialized) return;
#if defined(__linux__) || defined(__unix__) || defined(__CYGWIN__)
    gas_x11_shutdown();
#elif defined(__APPLE__) && TARGET_OS_MAC
    gas_macos_shutdown();
#endif
    gas_initialized = 0;
    gas_mutex_destroy(&gas_lock);
}

/* Determine current down state platform-dependently */
static int gas_platform_is_down(int vKey) {
#if defined(__linux__) || defined(__unix__) || defined(__CYGWIN__)
    return gas_x11_is_down(vKey);
#elif defined(__APPLE__) && TARGET_OS_MAC
    return gas_macos_is_down(vKey);
#else
    return 0;
#endif
}

/* The public GetAsyncKeyState implementation for non-Windows */
SHORT GetAsyncKeyState(int vKey) {
    if (!gas_initialized) {
        /* lazy init (best-effort) */
        if (!GAS_Init()) {
            return 0;
        }
    }

    if (vKey < 0 || vKey > 0xFF) return 0;

    gas_mutex_lock(&gas_lock);

    int is_down = gas_platform_is_down(vKey) ? 1 : 0;
    int prev = gas_prev_down[vKey] ? 1 : 0;

    SHORT ret = 0;
    if (is_down) ret |= 0x8000; /* high-order bit - currently down */

    /* low-order bit: set if key was pressed since last call */
    if (is_down && !prev) {
        ret |= 0x0001;
    }

    /* Update previous state to current */
    gas_prev_down[vKey] = is_down ? 1 : 0;

    gas_mutex_unlock(&gas_lock);
    return ret;
}

#endif /* _WIN32 */

#endif /* GETASYNCKEYSTATE_IMPLEMENTATION */

#endif /* GETASYNCKEYSTATE_H */
